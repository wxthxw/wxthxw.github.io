<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>ES6学习小结</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 0px 2px; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { overflow-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n3"><a class="md-toc-inner" href="#es%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93">ES学习小结</a></span><span class="md-toc-item md-toc-h2" data-ref="n6"><a class="md-toc-inner" href="#1-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">1 变量声明</a></span><span class="md-toc-item md-toc-h2" data-ref="n12"><a class="md-toc-inner" href="#2-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">2 解构赋值</a></span><span class="md-toc-item md-toc-h3" data-ref="n15"><a class="md-toc-inner" href="#%EF%BC%881%EF%BC%89%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%A6">（1）扩展运算符…</a></span><span class="md-toc-item md-toc-h3" data-ref="n18"><a class="md-toc-inner" href="#%EF%BC%882%EF%BC%89%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">（2）默认值与默认参数</a></span><span class="md-toc-item md-toc-h2" data-ref="n25"><a class="md-toc-inner" href="#3-%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9">3 扩展内容</a></span><span class="md-toc-item md-toc-h3" data-ref="n26"><a class="md-toc-inner" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95">（1）数值扩展</a></span><span class="md-toc-item md-toc-h3" data-ref="n37"><a class="md-toc-inner" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95">（2）字符串扩展</a></span><span class="md-toc-item md-toc-h3" data-ref="n46"><a class="md-toc-inner" href="#%EF%BC%883%EF%BC%89%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95">（3）对象扩展</a></span><span class="md-toc-item md-toc-h3" data-ref="n58"><a class="md-toc-inner" href="#%EF%BC%884%EF%BC%89%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95">（4）数组扩展</a></span><span class="md-toc-item md-toc-h3" data-ref="n65"><a class="md-toc-inner" href="#%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95">（5）函数扩展</a></span><span class="md-toc-item md-toc-h2" data-ref="n91"><a class="md-toc-inner" href="#4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4 数据结构与数据类型</a></span><span class="md-toc-item md-toc-h3" data-ref="n92"><a class="md-toc-inner" href="#%EF%BC%881%EF%BC%89set">（1）Set</a></span><span class="md-toc-item md-toc-h3" data-ref="n134"><a class="md-toc-inner" href="#%EF%BC%882%EF%BC%89symbol">（2）symbol</a></span><span class="md-toc-item md-toc-h3" data-ref="n161"><a class="md-toc-inner" href="#%EF%BC%883%EF%BC%89map">（3）Map</a></span><span class="md-toc-item md-toc-h2" data-ref="n193"><a class="md-toc-inner" href="#5-promise">5 Promise</a></span><span class="md-toc-item md-toc-h2" data-ref="n226"><a class="md-toc-inner" href="#6-proxy%E4%B8%8Ereflect">6 Proxy与Reflect</a></span><span class="md-toc-item md-toc-h3" data-ref="n227"><a class="md-toc-inner" href="#%EF%BC%881%EF%BC%89proxy">（1）proxy</a></span><span class="md-toc-item md-toc-h3" data-ref="n241"><a class="md-toc-inner" href="#%EF%BC%882%EF%BC%89reflect">（2）Reflect</a></span><span class="md-toc-item md-toc-h2" data-ref="n253"><a class="md-toc-inner" href="#7-class">7 Class</a></span><span class="md-toc-item md-toc-h2" data-ref="n284"><a class="md-toc-inner" href="#8-module">8 Module</a></span><span class="md-toc-item md-toc-h2" data-ref="n317"><a class="md-toc-inner" href="#9-iterator%E4%B8%8Egenerator">9 Iterator与Generator</a></span><span class="md-toc-item md-toc-h3" data-ref="n318"><a class="md-toc-inner" href="#%EF%BC%881%EF%BC%89iterator">（1）Iterator</a></span><span class="md-toc-item md-toc-h3" data-ref="n334"><a class="md-toc-inner" href="#%EF%BC%882%EF%BC%89generator">（2）Generator</a></span></p></div><h1><a name="es%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93" class="md-header-anchor"></a><span>ES学习小结</span></h1><p><span>		</span><span>自从开始从事前端工作后,深感对技术栈欠缺明确的认知，很多东西似是而非，一知半解。在经过跟同样从事前端行业的朋友交流一番后，痛定思痛，决心从根本开始学起，本次学习将沿着以下的思维导图进行更为深入的基础开始，期望可以解答之前尚存的疑虑。</span></p><p><img src='/1895788-20200106105648464-1625808418.png' alt='img' referrerPolicy='no-referrer' /></p><h2><a name="1-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E" class="md-header-anchor"></a><span>1 变量声明</span></h2><p><span>		</span><span>ES5中，使用var关键词进行变量的声明，存在声明的变量或函数都将提升到函数的最顶部（作用域提升），导致可以在使用变量之后再声明变量，会导致代码编写行为不规范。而ES6新增的let及const的作用域都是当前的代码块，区别在于，let声明的变量可以修改，而const 声明的是常量，不能修改。</span></p><p><a href='/1895788-20191221160715241-1457095258.png'><img src='/1895788-20191221160715731-517419839.png' alt='image' referrerPolicy='no-referrer' /></a><a href='/1895788-20191221160716080-1633864985.png'><img src='/1895788-20191221160716460-739872839.png' alt='image' referrerPolicy='no-referrer' /></a><a href='/1895788-20191221160716860-1413212188.png'><img src='/1895788-20191221160717199-669969150.png' alt='image' referrerPolicy='no-referrer' /></a></p><p><span>补充，var声明变量可以重复声明，而let 、const不允许（function跟var存在相同情况，函数可以提升，且可以重复声明）</span></p><p><span>作用域详见：</span><a href='https://www.cnblogs.com/hxw1024/p/12074362.html' target='_blank' class='url'>https://www.cnblogs.com/hxw1024/p/12074362.html</a></p><p><a href='/1895788-20191218175955401-1372958116.png'><img src='/1895788-20191218175955699-2140359453.png' alt='image' referrerPolicy='no-referrer' /></a></p><h2><a name="2-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" class="md-header-anchor"></a><span>2 解构赋值</span></h2><p><span>		</span><span>解构顾名思义按照一定的结构“解析”一个对象，通过这种方式我们可以从数组或对象中取值，本质上属于 </span><strong><span>模式匹配</span></strong><span>，这是</span><code>ES6</code><span>给我们提供的新语法，只要等号两边的模式相同即可解析相应的值。</span></p><p><a href='/1895788-20191221160717543-1324091721.png'><img src='/1895788-20191221160719813-889468685.png' alt='image' referrerPolicy='no-referrer' /></a></p><h3><a name="%EF%BC%881%EF%BC%89%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%A6" class="md-header-anchor"></a><span>（1）扩展运算符…</span></h3><p><span>       在使用解构赋值的时候，可以使用扩展运算符</span><code>...</code><span>来将剩余值统一放入一个对象中，</span></p><p><img src='/1895788-20191221160721690-1608828425.png' alt='image' referrerPolicy='no-referrer' /></p><h3><a name="%EF%BC%882%EF%BC%89%E9%BB%98%E8%AE%A4%E5%80%BC%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" class="md-header-anchor"></a><span>（2）默认值与默认参数</span></h3><p><span>		</span><span>在我们使用解构赋值的时候，可以为不存在的值或值为undefined赋默认值</span></p><p><img src='/1895788-20191221160722455-1221647317.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>		</span><span>当然了。也可以将默认值换成默认函数（返回一个默认值）：</span></p><p><img src='/1895788-20191221160723533-641674622.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>		</span><span>函数形参也可以使用这种写法：</span></p><p><img src='/1895788-20191221160724152-402246044.png' alt='image' referrerPolicy='no-referrer' /></p><h2><a name="3-%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9" class="md-header-anchor"></a><span>3 扩展内容</span></h2><h3><a name="%EF%BC%881%EF%BC%89%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95" class="md-header-anchor"></a><span>（1）数值扩展</span></h3><p><span>1、从ES6之后，使用前缀0b代表二进制数，使用0o代表八进制数，转换成十进制用Number（）函数，在非严格模式下，0o011===011返回为true,在严格模式下会报错。</span></p><p><span>2、新增的Number方法：</span></p><p><a href='/1895788-20191224230359946-888262214.png'><img src='/1895788-20191224230401088-242851805.png' alt='image' referrerPolicy='no-referrer' /></a></p><p><span>3、新增的Math方法：</span></p><p><a href='/1895788-20191224230401704-847746295.png'><img src='/1895788-20191224230403938-133536149.png' alt='image' referrerPolicy='no-referrer' /></a></p><p><span>4、左移运算符&lt;&lt; 和 右移运算符 &gt;&gt;</span></p><p><span>左移运算符&lt;&lt;: 在数字不溢出的情况下，左移n位相当于乘以2的n次方(当然首先要转换成二进制)</span></p><p><span>右移运算符&gt;&gt;: 与左移相反，高位的空位补符号位，正数补0，负数补1</span></p><p><span>无符号右移运算符&gt;&gt;&gt;:不考虑是否正负</span></p><p><span>指数运算符: 2**5相当于2的5次方</span></p><h3><a name="%EF%BC%882%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95" class="md-header-anchor"></a><span>（2）字符串扩展</span></h3><p><span>1、Unicode表示法：大括号包含表示Unicode字符(\u{0xXX}或\u{0XXX})</span></p><p><a href='/1895788-20191224230405774-764661575.png'><img src='/1895788-20191224230407782-316468207.png' alt='image' referrerPolicy='no-referrer' /></a></p><p><span>2、字符串遍历：可通过for-of遍历字符串</span></p><p><span>3、字符串模板：可单行可多行可插入变量的增强版字符串 也就是 ``</span></p><p><span>4、标签模板：函数参数的特殊调用（也就是${变量}）</span></p><p><a href='/1895788-20191224230408857-1661023179.png'><img src='/1895788-20191224230409222-384068992.png' alt='image' referrerPolicy='no-referrer' /></a></p><p><span>5、新增的方法：</span></p><p><a href='/1895788-20191224230409594-1652530466.png'><img src='/1895788-20191224230411820-487413677.png' alt='image' referrerPolicy='no-referrer' /></a></p><h3><a name="%EF%BC%883%EF%BC%89%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95" class="md-header-anchor"></a><span>（3）对象扩展</span></h3><p><span>1、对象属性的简洁写法</span></p><p><span>属性名简写</span></p><p><a href='/1895788-20191224230413799-66308013.png'><img src='/1895788-20191224230414203-667144094.png' alt='image' referrerPolicy='no-referrer' /></a><a href='/1895788-20191224230414913-1651010646.png'><img src='/1895788-20191224230415319-1440787543.png' alt='image' referrerPolicy='no-referrer' /></a><span>[</span><img src='/1895788-20191224230415929-797416216.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>方法名简写：</span></p><p><span>[</span><img src='/1895788-20191224230417918-1099684787.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>2、</span><strong><span>属性名表达式</span></strong></p><p><span>3、</span><strong><span>方法的name属性</span></strong></p><p><span>4、</span><strong><span>属性的可枚举性和遍历</span></strong></p><p><span>5、</span><strong><span>super关键字</span></strong><span>：指向当前对象的原型对象(只能用在对象的简写方法中</span><code>method() {}</code><span>)</span></p><p><span>6、新增的方法</span></p><p><span>[</span><img src='/1895788-20191224230419428-1884534432.png' alt='image' referrerPolicy='no-referrer' /></p><h3><a name="%EF%BC%884%EF%BC%89%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95" class="md-header-anchor"></a><span>（4）数组扩展</span></h3><p><span>新增的数组方法：</span></p><p><img src='/1578885374826.png' alt='1578885374826' referrerPolicy='no-referrer' /></p><p><span>具体的应用场景：</span></p><p><img src='/1578885595130.png' alt='1578885595130' referrerPolicy='no-referrer' /></p><p><span>补充说明</span></p><p><span>     使用keys()、values()、entries()返回的遍历器对象，可用for-of自动遍历或next()手动遍历</span></p><h3><a name="%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95" class="md-header-anchor"></a><span>（5）函数扩展</span></h3><p><span>主要是多了这些方法</span></p><p><img src='/1578887426297.png' alt='1578887426297' referrerPolicy='no-referrer' /></p><p><span>其中，尾调用的进阶用法尾递归值得我们重视，我们知道递归调用是非常消耗内存的，动辄需要同时保存成百上千的调用帧，容易造成“栈溢出”，但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</span></p><p>&nbsp;</p><p><span>箭头函数</span></p><p><img src='/1895788-20191221160725600-1810918877.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>		</span><span>箭头函数的特性：</span>
<span>​</span><span>			</span><span>1.没有自身的this</span>
<span>​</span><span>			</span><span>2.不能使用new</span>
<span>​</span><span>			</span><span>3.没有arguments（参数列表）</span></p><p><span>==========================================================</span></p><p><span>1、没有自身的this</span>
<span>	</span><span>  我们来看普通的函数(返回的函数相当于fn1函数内的嵌套函数)：</span></p><p><img src='/1895788-20191221160727536-211192563.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>  </span><span>	</span><span>如果是箭头函数的this执行会是怎样的呢？</span></p><p><img src='/1895788-20191221160729104-495222436.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>call方法的使用详见：</span><a href='https://www.cnblogs.com/hxw1024/p/12077636.html' target='_blank' class='url'>https://www.cnblogs.com/hxw1024/p/12077636.html</a></p><p><span>2、不能使用new</span></p><p><img src='/1895788-20191221160729828-1848197804.png' alt='image' referrerPolicy='no-referrer' /><img src='/1895788-20191221160730449-287035811.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>3、没有arguments</span>
<span>首先，什么是arguments呢？</span></p><p><img src='/1895788-20191221160731179-1118299419.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>我们给min函数提供了实参，但是min函数本身是没有形参的，那它输出的结果是这样子的：</span></p><p><img src='/1895788-20191221160731814-280270101.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>返回的是名为arguments的列表，这就是我们函数调用时的参数列表，普通函数可以打印，那换成箭头函数呢？</span></p><p><img src='/1895788-20191221160732512-810534816.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>当然，如果你想更了解arguments，可以参见：</span><a href='https://www.jianshu.com/p/d7ed5ade67a3' target='_blank' class='url'>https://www.jianshu.com/p/d7ed5ade67a3</a>
<span>另外附上arguments的实践应用：</span>
<span>制定一个求出最大值的函数：</span></p><p><img src='/1895788-20191221160733115-832585927.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>补充说明：</span></p><p><span>1、箭头函数不可使用yield命令，因此箭头函数不能用作Generator函数</span>
<span>2、箭头函数返回对象时必须在对象外面加上括号</span></p><h2><a name="4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="md-header-anchor"></a><span>4 数据结构与数据类型</span></h2><h3><a name="%EF%BC%881%EF%BC%89set" class="md-header-anchor"></a><span>（1）Set</span></h3><p><span>什么是set? ES6新增的数据结构，类似于数组，但它的一大特性就是所有元素都是唯一的，没有重复。</span></p><p><span>很显然，它可以做到数组元素的去重：</span></p><p><span>[</span><img src='/1895788-20191231180013269-753805795.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>方法：</span></p><p><span>[</span><img src='/1895788-20191231180013727-392420174.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>属性：</span></p><p><span>[</span><img src='/1895788-20191231180014234-432255080.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>应用场景:</span></p><p><span>1、字符串去重</span></p><p><span>[</span><img src='/1895788-20191231180014652-987186500.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>2、数组去重</span></p><p><span>[</span><img src='/1895788-20191231180015069-2114002406.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>3、集合数组</span></p><p><span>[</span><img src='/1895788-20191231180015547-477483909.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>4、映射集合</span></p><p><span>[</span><img src='/1895788-20191231180015990-1374378993.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>注意事项：</span></p><p><span>1、遍历顺序：插入顺序</span></p><p><span>2、没有键只有值，可认为键和值两值相等</span></p><p><span>3、添加多个</span><code>NaN</code><span>时，只会存在一个</span><code>NaN</code></p><p><span>4、添加相同的对象时，会认为是不同的对象</span></p><p><span>5、添加值时不会发生类型转换(</span><code>5 !== &quot;5&quot;</code><span>)</span></p><p><code>6、keys()</code><span>和</span><code>values()</code><span>的行为完全一致，</span><code>entries()</code><span>返回的遍历器同时包括键和值且两值相等</span></p><p><span>====================================</span></p><p><span>补充说明：WeakSet</span></p><p><span>什么是WeakSet？ 和Set结构类似，成员值只能是对象</span></p><p><span>[</span><img src='/1895788-20191231180016686-1282838196.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>应用场景</span></p><ul><li><span>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</span></li><li><span>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在</span><code>WeakSet结构</code><span>中的引用就会自动销毁</span></li></ul><p><span>注意事项</span></p><ul><li><span>成员都是</span><code>弱引用</code><span>，垃圾回收机制不考虑</span><code>WeakSet结构</code><span>对此成员的引用</span></li><li><span>成员不适合引用，它会随时消失，因此ES6规定</span><code>WeakSet结构不可遍历</code></li><li><span>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于</span><code>WeakSet结构</code><span>中</span></li></ul><h3><a name="%EF%BC%882%EF%BC%89symbol" class="md-header-anchor"></a><span>（2）symbol</span></h3><p><span>我们知道ES5中的基本数据类型有undefined、null、boolean、number、string，引用类型有object（包含</span><code>Array</code><span>、</span><code>Function</code><span>、</span><code>Date</code><span>、</span><code>RegExp</code><span>、</span><code>Error</code><span>）；在ES6中新增了一个基本数据类型：symbol。</span></p><p><span>那什么是symbol？类似于一种标识唯一性的ID，独一无二。</span></p><p><span>方法：</span></p><p><span>[</span><img src='/1895788-20191231214712114-566416138.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>内置方法：</span></p><p><span>[</span><img src='/1895788-20191231214713325-803751702.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>应用场景：</span></p><p><span>1、唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</span></p><p><img src='/1578477132760.png' alt='1578477132760' referrerPolicy='no-referrer' /></p><p><span> 可以利用这一特性，对不同常量进行区分（无需为常量进行赋唯一值，本身symbol类型就保证了唯一性）</span></p><p><span>2、消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</span></p><p><span>3、遍历属性名：无法通过</span><code>for-in</code><span>、</span><code>for-of</code><span>、</span><code>Object.keys()</code><span>、</span><code>Object.getOwnPropertyNames()</code><span>、</span><code>JSON.stringify()</code><span>返回，只能通过Object.getOwnPropertySymbols和Reflect.ownKeys（）返回</span></p><p><img src='/1578477505250.png' alt='1578477505250' referrerPolicy='no-referrer' /></p><p><span>4、启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(</span><code>window</code><span>和</span><code>global</code><span>)，使用</span><code>Symbol.for()</code><span>来模拟全局的</span><code>Singleton模式</code></p><p><span>5、定义类的私有属性/方法</span></p><p><img src='/1578541248956.png' alt='1578541248956' referrerPolicy='no-referrer' /><span>      </span><img src='/1578541226729.png' alt='1578541226729' referrerPolicy='no-referrer' /></p><p><span>6、注册和获取全局的Symbol</span></p><p><span> 我们知道，Symbol（）创建的都是唯一的，那如果我们想要在创建一个Symbol数值后，再去获取它，怎么做呢？</span></p><p><img src='/1578541719083.png' alt='1578541719083' referrerPolicy='no-referrer' /></p><p><span>补充说明：</span></p><p><span>1、Symbol()</span><code>生成一个原始类型的值不是对象，因此</code><span>Symbol()</span><code>前不能使用</code><span>new命令</span></p><p><span>2、Symbol()</span><code>参数表示对当前</code><span>Symbol值</span><code>的描述，相同参数的</code><span>Symbol()`返回值不相等</span></p><p><span>3、Symbol值不能与其他类型的值进行运算</span></p><p><span>4、Symbol值</span><code>可通过</code><span>String()</span><code>或</code><span>toString()显式转为字符串</span></p><p><span>5、Symbol值作为对象属性名时，此属性是公开属性，但不是私有属性</span></p><p><span>6、Symbol值</span><code>作为对象属性名时，只能用方括号运算符(</code><span>[]</span><code>)读取，不能用点运算符(</code><span>.)读取</span></p><h3><a name="%EF%BC%883%EF%BC%89map" class="md-header-anchor"></a><span>（3）Map</span></h3><p><span>什么是Map？类似于对象的数据结构，成员键可以是任何类型的值。</span></p><p><span>具体化：我们知道原先对象内属性名只能是字符串，而Map属性名可以是字符串，也可以是对象或数组。它是一个更完善的hash结构。</span></p><p><span>[</span><img src='/1895788-20200101103049863-1829343784.png' alt='image' referrerPolicy='no-referrer' /><span>[</span><img src='/1895788-20200101103050762-130322687.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>属性：</span></p><p><span>[</span><img src='/1895788-20200101103051605-75865541.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>方法：</span></p><p><span>[</span><img src='/1895788-20200101103052267-1123431474.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>补充说明：</span></p><p><span>1、遍历顺序：插入顺序</span></p><p><span>2、对同一个键多次赋值，后面的值将覆盖前面的值</span></p><p><span>3、对同一个对象的引用，被视为一个键</span></p><p><span>4、对同样值的两个实例，被视为两个键</span></p><p><span>5、键跟内存地址绑定，只要内存地址不一样就视为两个键</span></p><p><span>6、添加多个以</span><code>NaN</code><span>作为键时，只会存在一个以</span><code>NaN</code><span>作为键的值</span></p><p><code>7、Object结构</code><span>提供</span><code>字符串—值</code><span>的对应，</span><code>Map结构</code><span>提供</span><code>值—值</code><span>的对应</span></p><p><span>================================================</span></p><p><span>WeakMap</span></p><p><span>什么是WeakMap ？ 和Map结构类似，成员键只能是对象。</span></p><p><span>属性：</span><strong><span>constructor</span></strong><span>：构造函数，返回WeakMap</span></p><p><span>方法：</span></p><p><span>[</span><img src='/1895788-20200101103053678-1158790879.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>应用场景：</span></p><p><span>     1、储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</span></p><p><span>     2、部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</span></p><p><span>补充说明：</span></p><p><span>1、成员键都是</span><code>弱引用</code><span>，垃圾回收机制不考虑</span><code>WeakMap结构</code><span>对此成员键的引用</span></p><p><span>2、成员键不适合引用，它会随时消失，因此ES6规定</span><code>WeakMap结构不可遍历</code></p><p><span>3、其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于</span><code>WeakMap结构</code><span>中</span></p><p><span>4、一旦不再需要，成员会自动消失，不用手动删除引用</span></p><p><span>5、弱引用的</span><code>只是键而不是值</code><span>，值依然是正常引用</span></p><p><span>6、即使在外部消除了成员键的引用，内部的成员值依然存在</span></p><h2><a name="5-promise" class="md-header-anchor"></a><span>5 Promise</span></h2><p><span>promise的起源</span></p><p><span> </span><span>		</span><span> 在之前，我们处理异步网络请求的时候，往往会采用这样的写法：</span></p><p><img src='/1895788-20191223211031621-821140862.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>		</span><span>再复杂一点，我们需要在请求完第一个api后，再去请求第二个接口，那么就变成这样了：</span></p><p><img src='/1895788-20191223211032360-1039023021.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>  </span><span>	</span><span>基于此，在需求增加的情况下，我们很可能会面临一场灾难性的到来--回调地狱。</span></p><p><img src='/1895788-20191223211034257-1421759683.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>造成的后果是：</span></p><p><span>1、代码庞杂臃肿，可读性极差</span></p><p><span>2、耦合度过高，难以进行后期的维护</span></p><p><span>3、代码复用性差，变相让代码更加臃肿</span></p><p><span>4、容易滋生bug，而且需要在回调里处理异常</span></p><p><span>这时候，怎么解决这种问题呢？我们希望可以以一种更加友好的方式进行代码的编写，promise规范由此便诞生了。</span></p><p><span>那什么是promise呢？</span></p><p><span>promise是异步编程的一种解决方案。目前业内实现解决回调的地狱的有Q和bluebird。</span></p><p><img src='/1895788-20191223214525677-1291111435.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>它的定义是：一个可以一起执行多个任务，函数调用后不会立即返回执行的结果的异步操作。</span></p><p><img src='/1578818181721.png' alt='1578818181721' referrerPolicy='no-referrer' /></p><p><span>方法：</span></p><p><img src='/1578883444559.png' alt='1578883444559' referrerPolicy='no-referrer' /></p><p><span>具体化：比如以下这个例子，p1将数值转换成promise对象，而Promise.all()方法则等待全部实例变更后，再将所有的结果遍历返回。</span></p><p><img src='/1578883155713.png' alt='1578883155713' referrerPolicy='no-referrer' /></p><p><span>那如果中途报错呢，还能继续执行遍历返回结果吗？</span></p><p><img src='/1578884140563.png' alt='1578884140563' referrerPolicy='no-referrer' /></p><p><span>还差一个Promise.race()未曾提及，那这个方法是该怎么使用呢？</span></p><p><img src='/1578884478155.png' alt='1578884478155' referrerPolicy='no-referrer' /></p><p><span>这个作用如其名，所有实例哪个先运行完，返回该实例的值后，不再执行尚未执行完的实例。</span></p><p><span>实际应用场景：</span></p><p><img src='/1578884935511.png' alt='1578884935511' referrerPolicy='no-referrer' /></p><p><span>补充说明;</span></p><p><span>1、只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</span>
<span>2、状态改变只有两种可能：从pending变为resolved、从pending变为rejected</span>
<span>3、一旦新建Promise对象就会立即执行，无法中途取消</span>
<span>4、不设置回调函数，内部抛错不会反应到外部</span>
<span>5、当处于pending时，无法得知目前进展到哪一个阶段</span>
<span>6、实例状态变为resolved或rejected时，会触发then()绑定的回调函数</span>
<span>7、resolve()和reject()的执行总是晚于本轮循环的同步任务</span>
<span>8、then()返回新实例，其后可再调用另一个then()</span>
<span>9、then()运行中抛出错误会被catch()捕获</span>
<span>10、reject()的作用等同于抛出错误</span>
<span>11、实例状态已变成resolved时，再抛出错误是无效的，不会被捕获，等于没有抛出</span>
<span>12、实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个catch()捕获</span>
<span>13、不要在then()里定义rejected状态的回调函数(不使用其第二参数)</span>
<span>14、建议使用catch()捕获错误，不要使用then()第二个参数捕获</span>
<span>15、没有使用catch()捕获错误，实例抛错不会传递到外层代码，即不会有任何反应</span>
<span>16、作为参数的实例定义了catch()，一旦被rejected并不会触发Promise.all()的catch()</span>
<span>17、Promise.reject()的参数会原封不动地作为rejected的理由，变成后续方法的参数</span></p><p><span>## </span></p><h2><a name="6-proxy%E4%B8%8Ereflect" class="md-header-anchor"></a><span>6 Proxy与Reflect</span></h2><h3><a name="%EF%BC%881%EF%BC%89proxy" class="md-header-anchor"></a><span>（1）proxy</span></h3><p><span>定义：修改某些操作的默认行为。</span></p><p><span>具体化：可以理解成在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</span></p><p><span>还是不明白？那就举个具体的场景：我们想要购买海外的商品，那可能需要找代购，代购到国外买到商品后，回国后再转交给你。在这个场景中，代购起到了中介代理购买的作用，也就是proxy构造函数起到的作用。</span></p><p><span>参数形式：</span></p><p><span>[</span><img src='/1895788-20200102174113174-501380417.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>方法：</span></p><p><span>[</span><img src='/1895788-20200102174113802-1517316603.png' alt='image' referrerPolicy='no-referrer' /></p><p><span>实践方法：</span></p><p><img src='/1578473082486.png' alt='1578473082486' referrerPolicy='no-referrer' /></p><p><span>应用场景：(表单验证)</span></p><p><span>[</span><img src='/1895788-20200102174114494-210615905.png' alt='image' referrerPolicy='no-referrer' /></p><p><a href='https://segmentfault.com/a/1190000019198822' target='_blank' class='url'>https://segmentfault.com/a/1190000019198822</a></p><p><a href='https://www.cnblogs.com/kdcg/p/9145385.html' target='_blank' class='url'>https://www.cnblogs.com/kdcg/p/9145385.html</a></p><h3><a name="%EF%BC%882%EF%BC%89reflect" class="md-header-anchor"></a><span>（2）Reflect</span></h3><p><span>		</span><span>这就不得不提到proxy了，上文我们提到proxy可以修改操作的默认行为，那获取默认行为的工作就交给了reflect。Reflect</span><code>对象的方法与</code><span>Proxy</span><code>对象的方法一一对应，只要是</code><span>Proxy</span><code>对象的方法，就能在</code><span>Reflect</span><code>对象上找到对应的方法。这就让</code><span>Proxy</span><code>对象可以方便地调用对应的</code><span>Reflect</span><code>方法，完成默认行为，作为修改行为的基础。也就是说，不管</code><span>Proxy</span><code>怎么修改默认行为，你总可以在</code><span>Reflect上获取默认行为。</span></p><p><img src='/1578471714869.png' alt='1578471714869' referrerPolicy='no-referrer' /></p><p><span>具体化：Reflect可以修改某些Object方法返回的结果，更为合理（抛出异常 =&gt; 返回false）</span></p><p><img src='/1578472231367.png' alt='1578472231367' referrerPolicy='no-referrer' /></p><p><span>具体化：将Object操作（命令式）变为函数行为，而且Reflect对象上可以拿到语言内部的方法。</span></p><p><span>方法:</span></p><p><img src='/1578472670775.png' alt='1578472670775' referrerPolicy='no-referrer' /></p><p><span>=============================================================</span></p><p><span>应用场景</span></p><p><span> 观察者模式（函数自动观察数据对象，一旦数据有变化，函数就会自动执行）：</span></p><p><img src='/1578476190420.png' alt='1578476190420' referrerPolicy='no-referrer' /></p><h2><a name="7-class" class="md-header-anchor"></a><span>7 Class</span></h2><p><span>什么是class? 对一类具有共同特征的事物的抽象(构造函数语法糖)。</span></p><p><span>具体化：类本身指向构造函数，所有方法定义在</span><code>prototype</code><span>上，可看作构造函数的另一种写法。</span></p><p><img src='/1578552999201.png' alt='1578552999201' referrerPolicy='no-referrer' /></p><p><span>怎么解释呢？我们之前如果想要生成一个对象实例的话，我们可以通过构造函数实现：</span></p><p><img src='/1578552522578.png' alt='1578552522578' referrerPolicy='no-referrer' /></p><p><span>那它是怎么执行这些代码的呢？</span></p><p><img src='/1578552612730.png' alt='1578552612730' referrerPolicy='no-referrer' /></p><p><span>如果用class去实现上文的构造对象实例，我们可以这样做：</span></p><p><img src='/1578552700122.png' alt='1578552700122' referrerPolicy='no-referrer' /></p><p><span>如果往class追加方法，我们可以这样做：</span></p><p><img src='/1578554359487.png' alt='1578554359487' referrerPolicy='no-referrer' /><img src='/1578554571062.png' alt='1578554571062' referrerPolicy='no-referrer' /></p><p><span>那它跟原先的构造函数有什么区别呢？</span></p><p><img src='/1578624583102.png' alt='1578624583102' referrerPolicy='no-referrer' /></p><p><span>区别在于：它是不可枚举的。</span></p><p><span>方法：</span></p><p><img src='/1578624874041.png' alt='1578624874041' referrerPolicy='no-referrer' /></p><p><img src='/1578626390871.png' alt='1578626390871' referrerPolicy='no-referrer' /></p><p><span>属性：</span></p><ul><li><strong><strong><span>proto</span></strong></strong><span>：</span><code>构造函数的继承</code><span>(总是指向</span><code>父类</code><span>)</span></li><li><strong><strong><span>proto</span></strong><span>.</span><strong><span>proto</span></strong></strong><span>：子类的原型的原型，即父类的原型(总是指向父类的</span><code>__proto__</code><span>)</span></li><li><strong><span>prototype.</span><strong><span>proto</span></strong></strong><span>：</span><code>属性方法的继承</code><span>(总是指向父类的</span><code>prototype</code><span>)</span></li></ul><p><span>应用场景：</span></p><p><span>1、私有属性方法</span><span>	</span></p><p><img src='/1578627535790.png' alt='1578627501590' referrerPolicy='no-referrer' /></p><p><span>2、继承混合类</span></p><p><img src='/1578640140599.png' alt='1578640140599' referrerPolicy='no-referrer' /></p><h2><a name="8-module" class="md-header-anchor"></a><span>8 Module</span></h2><p><span>什么是module？也就是模块，目的就是通过命名空间对各类业务对象进行一定的封装，防止命名冲突。</span></p><p><span>命令：</span></p><p><strong><span>export</span></strong><span>：规定模块对外接口</span></p><p><img src='/1578640883666.png' alt='1578640883666' referrerPolicy='no-referrer' /></p><p><strong><span>import</span></strong><span>：导入模块内部功能</span></p><p><img src='/1578641068338.png' alt='1578641068338' referrerPolicy='no-referrer' /></p><p><strong><span>复合模式</span></strong><span>：变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</span></p><p><img src='/1578641691817.png' alt='1578641691817' referrerPolicy='no-referrer' /></p><p><span>加载的实现方式：</span></p><p><img src='/1578642486625.png' alt='1578642486625' referrerPolicy='no-referrer' /></p><p><span>模块方案：</span></p><ul><li><strong><span>CommonJS</span></strong><span>：用于服务器(动态化依赖) =&gt; Node就是运用这个规范</span></li><li><strong><span>AMD</span></strong><span>：用于浏览器(动态化依赖)  =&gt; RequireJS 在推广过程中对模块定义的规范化产出</span></li><li><strong><span>CMD</span></strong><span>：用于浏览器(动态化依赖) =&gt;  SeaJS 在推广过程中对模块定义的规范化产出</span></li><li><strong><span>UMD</span></strong><span>：用于浏览器和服务器(动态化依赖)  =&gt; AMD和CommonJS的糅合</span></li><li><strong><span>ESM</span></strong><span>：用于浏览器和服务器(静态化依赖) =&gt; 就是ES6模块</span></li></ul><p><span>那不同不同模块方案间有什么不同呢？</span></p><p><span>例如CommonJS与ESM的区别就是：</span></p><p><img src='/1578751468696.png' alt='1578751468696' referrerPolicy='no-referrer' /></p><p><span>其它具体可以参考：</span></p><p><a href='https://www.cnblogs.com/chenwenhao/p/12153332.html#_label3' target='_blank' class='url'>https://www.cnblogs.com/chenwenhao/p/12153332.html#_label3</a></p><p><a href='https://www.jianshu.com/p/33d53cce8237' target='_blank' class='url'>https://www.jianshu.com/p/33d53cce8237</a></p><p><a href='https://blog.csdn.net/sinat_17775997/article/details/84066436' target='_blank' class='url'>https://blog.csdn.net/sinat_17775997/article/details/84066436</a></p><p><a href='https://www.jianshu.com/p/39c40db654ab' target='_blank' class='url'>https://www.jianshu.com/p/39c40db654ab</a></p><p><span>补充说明：</span></p><p><span>1、ES6模块中，顶层this指向undefined，不应该在顶层代码使用this</span>
<span>2、一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</span>
<span>3、export命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值</span>
<span>4、import命令大括号里的变量名必须与被导入模块对外接口的名称相同</span>
<span>5、import命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</span>
<span>6、import命令命令具有提升效果，会提升到整个模块的头部，首先执行</span>
<span>7、重复执行同一句import语句，只会执行一次</span>
<span>8、export default命令只能使用一次</span>
<span>9、export default命令导出的整体模块，在执行import命令时其后不能跟大括号</span>
<span>10、export default命令本质是输出一个名为default的变量，后面不能跟变量声明语句</span>
<span>11、export default命令本质是将后面的值赋给名为default的变量，可直接将值写在其后</span>
<span>12、export default命令和export {}命令可同时存在，对应复合导入</span>
<span>13、export命令和import命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</span>
<span>14、import()加载模块成功后，此模块会作为一个对象，当作then()的参数，可使用对象解构赋值来获取输出接口</span>
<span>15、同时动态加载多个模块时，可使用Promise.all()和import()相结合来实现</span>
<span>16、import()和结合async/await来书写同步操作的代码</span></p><h2><a name="9-iterator%E4%B8%8Egenerator" class="md-header-anchor"></a><span>9 Iterator与Generator</span></h2><h3><a name="%EF%BC%881%EF%BC%89iterator" class="md-header-anchor"></a><span>（1）Iterator</span></h3><p><span>定义：其实就是迭代器，可以为各种不同的数据结构提供统一的访问机制</span></p><p><span>原理：创建一个指针指向首个成员，按照次序使用next()指向下一个成员，直接到结束位置(数据结构只要部署Iterator接口就可完成遍历操作)</span></p><p><span>表现的形式：for-of(自动去寻找Iterator接口)</span></p><p><span>其实我们对这个Iterator并不陌生，在上文中一些场景中，我们已经有好几次用到了：</span></p><p><img src='/1578754300372.png' alt='1578754300372' referrerPolicy='no-referrer' /></p><p><span>还有下文中要提到的Generator中的 yield* 表达式，这也是我把它们放在一起讲的原因。</span></p><p><img src='/1578754707253.png' alt='1578754707253' referrerPolicy='no-referrer' /></p><p><span>另外的运用场合：</span></p><p><span>	</span><span>for..of、Array.from</span>
<span>​</span><span>	</span><span>Map()、Set()、WeakMap()、WeakSet()</span>
<span>​</span><span>	</span><span>Promise.all()、Promise.race()</span></p><p><span>那讲到这，for...of到底是什么，它跟我们之前用来遍历方法又有什么优势呢？</span></p><p><img src='/1578755411062.png' alt='1578755411062' referrerPolicy='no-referrer' /></p><p><span>对于没有Iterator接口类数组对象的遍历处理，我们可以用Array.from():</span></p><p><img src='/1578755882199.png' alt='1578755882199' referrerPolicy='no-referrer' /></p><p><span>而我们上文所讲的Map及Set中的运用则是如此：</span></p><p><img src='/1578755629017.png' alt='1578755629017' referrerPolicy='no-referrer' /></p><h3><a name="%EF%BC%882%EF%BC%89generator" class="md-header-anchor"></a><span>（2）Generator</span></h3><p><span>定义：就是生成器，封装多个内部状态的异步编程解决方案。</span></p><p><span>参数形式：</span></p><p><img src='/1578814027906.png' alt='1578814027906' referrerPolicy='no-referrer' /></p><p><span>我们发现它的函数内部有一些表达式，比如yield*与yield：</span></p><p><img src='/1578814832850.png' alt='1578814832850' referrerPolicy='no-referrer' /></p><p><span> 那yield*有什么应用场景呢？其实我们让它实现数组的扁平化：</span></p><p><img src='/1578815548355.png' alt='1578815548355' referrerPolicy='no-referrer' /></p><p><span>还可以给next（）方法进行传参：</span></p><p><img src='/1578816001012.png' alt='1578816001012' referrerPolicy='no-referrer' /></p><p><span>实际上，yield 表达式和 next 方法是 generator 函数的双向信息传递。yield 表达式向外传递 value 值，next 方法的参数向内传递值。</span></p><p><img src='/1578816917963.png' alt='1578816917963' referrerPolicy='no-referrer' /></p><p><span>补充说明：</span></p><p><span>1、每次调用next()，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个yield命令或return语句为止</span>
<span>2、函数内部可不用yield命令，但会变成单纯的暂缓执行函数(还是需要next()触发)</span>
<span>3、yield命令是暂停执行的标记，next()是恢复执行的操作</span>
<span>4、yield命令用在另一个表达式中必须放在圆括号里</span>
<span>5、yield命令用作函数参数或放在赋值表达式的右边，可不加圆括号</span>
<span>6、yield命令本身没有返回值，可认为是返回undefined</span>
<span>7、yield命令表达式为惰性求值，等next()执行到此才求值</span>
<span>8、函数调用后生成遍历器对象，此对象的Symbol.iterator是此对象本身</span>
<span>9、在函数运行的不同阶段，通过next()从外部向内部注入不同的值，从而调整函数行为</span>
<span>10、首个next()用来启动遍历器对象，后续才可传递参数</span>
<span>11、想首次调用next()时就能输入值，可在函数外面再包一层</span>
<span>12、一旦next()返回对象的done为true，for-of遍历会中止且不包含该返回对象</span>
<span>13、函数内部部署try-finally且正在执行try，那么return()会导致立刻进入finally，执行完finally以后整个函数才会结束</span>
<span>14、函数内部没有部署try-catch，throw()抛错将被外部try-catch捕获</span>
<span>15、throw()抛错要被内部捕获，前提是必须至少执行过一次next()</span>
<span>16、throw()被捕获以后，会附带执行下一条yield命令</span>
<span>17、函数还未开始执行，这时throw()抛错只可能抛出在函数外部</span></p><p><span>补充资料：</span></p><p><a href='https://www.jianshu.com/p/8c85189e7605' target='_blank' class='url'>https://www.jianshu.com/p/8c85189e7605</a></p><p>&nbsp;</p></div>
</body>
</html>